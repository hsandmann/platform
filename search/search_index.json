{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Plataformas, Microsservi\u00e7os e APIs","text":"<p>Carga Hor\u00e1ria: 80</p> <p>Semestre: 5\u00ba per\u00edodo</p>"},{"location":"#ementa","title":"Ementa","text":"<p>Conceitos de Aplica\u00e7\u00f5es em Mon\u00f3l\u00edto e Microservi\u00e7os; Conteineriza\u00e7\u00e3o; Padr\u00f5es de Constru\u00e7\u00e3o de Softwares (Design Patterns); Monitoramento e Rastreabilidade de Aplica\u00e7\u00f5es; Seguran\u00e7a (autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o); Mensageria; Dados Distribu\u00eddos; Orquestra\u00e7\u00e3o de computa\u00e7\u00e3o em nuvem, sistemas de gerenciamento, monitoramento e configura\u00e7\u00e3o de recursos virtualizados; Integra\u00e7\u00e3o entre Desenvolvimento e Opera\u00e7\u00e3o; Utiliza\u00e7\u00e3o de Plataformas em Nuvem para Produ\u00e7\u00e3o (Cloud Computing); Aspectos de automa\u00e7\u00e3o de gest\u00e3o de sistema em cloud \u2013 DevOps. Serverless computing \u2013 FaaS - function as a service; Utiliza\u00e7\u00e3o da Plataforma como Produto para Neg\u00f3cios: Infraestrutura como Servi\u00e7o (IaaS), Plataforma como Servi\u00e7o (PaaS) e Software como Servi\u00e7o (SaaS). Gest\u00e3o de n\u00edveis de servi\u00e7o (SLA - Service Level Agreement). Custos de projeto e de opera\u00e7\u00e3o de sistemas em cloud.</p>"},{"location":"#objetivos","title":"Objetivos","text":"<p>Ao final da disciplina o aluno ser\u00e1 capaz de:</p> <ol> <li>Tomar decis\u00f5es a respeito da escolha de estrat\u00e9gias de arquiteturas para o emprego de problemas computacionais;</li> <li>Implementar e interconectar aplica\u00e7\u00f5es computacionais para a constru\u00e7\u00e3o de plataformas de alto desempenho: escalabilidade por meio do uso de t\u00e9cnicas de computa\u00e7\u00e3o em nuvem;</li> <li>Administrar um sistema de gerenciamento de nuvem, provisionando a infraestrutura necess\u00e1ria como um servi\u00e7o;</li> <li>Construir, com o aux\u00edlio de frameworks, solu\u00e7\u00f5es de plataformas completas e integradas de forma profissional;</li> <li>Arquitetar e implementar linhas de produ\u00e7\u00f5es de softwares robustos (CI/CD);</li> <li>Analisar, projetar e especificar uma solu\u00e7\u00e3o de computa\u00e7\u00e3o em nuvem mista baseada em hardware, software e redes para atender aos requisitos de determinado pacto de n\u00edvel de servi\u00e7o (SLA);</li> <li>Planejar e analisar o uso de plataformas empresariais como subs\u00eddio para cria\u00e7\u00e3o de novos neg\u00f3cios (PaaS).</li> </ol>"},{"location":"#conteudo-programatico","title":"Conte\u00fado Program\u00e1tico","text":"<ol> <li>Conceitos de Arquitetura e Micro Servi\u00e7os;</li> <li>Micro Servi\u00e7os com Interface API - RESTful;</li> <li>Introdu\u00e7\u00e3o a Cont\u00eaineres;</li> <li>Introdu\u00e7\u00e3o e Implementa\u00e7\u00e3o de Design Patterns;</li> <li>Apresenta\u00e7\u00e3o de Design Patterns mais Complexos: Seguran\u00e7a, Mensageria, Cache, etc;</li> <li>Fundamentos de Computa\u00e7\u00e3o em Nuvem.</li> <li>Orquestra\u00e7\u00e3o, Implementa\u00e7\u00e3o e Monitoramento de Ambientes Virtualizados e Distribu\u00eddos;</li> <li>Infraestrutura como um Servi\u00e7o.</li> <li>Redes Definidas por Software;</li> <li>Software como um Servi\u00e7o;</li> <li>Gest\u00e3o de N\u00edveis de Servi\u00e7o.</li> </ol>"},{"location":"#bibliografia-basica","title":"Bibliografia B\u00e1sica","text":"<p>Livros:</p> <ol> <li> <p>ROMAN, Ed; AMBLER, Scott W.; JEWELL, Tyler. Dominando Enterprise Javabeans. Porto Alegre: Bookman, 2004. E-book. ISBN 9788577804061. Dispon\u00edvel em: https://integrada.minhabiblioteca.com.br/#/books/9788577804061. Acesso em: 30 de maio de 2023.</p> </li> <li> <p>ALVES, William Pereira. Java para Web - Desenvolvimento de Aplica\u00e7\u00f5es. S\u00e3o Paulo: \u00c9rica, 2015. E-book. ISBN 9788536519357. Dispon\u00edvel em: https://integrada.minhabiblioteca.com.br/#/books/9788536519357. Acesso em: 30 de maio de 2023.</p> </li> <li> <p>FREEMAN, Emily. DevOps Para Leigos. Rio de Janeiro: Editora Alta Books, 2021. E-book. ISBN 9788550816661. Dispon\u00edvel em: https://integrada.minhabiblioteca.com.br/#/books/9788550816661. Acesso em: 30 de maio de 2023.</p> </li> </ol>"},{"location":"#bibliografia-complementar","title":"Bibliografia Complementar","text":"<p>Livros:</p> <ol> <li> <p>XU, A., System Design Interview - An insider's guide, 1\u00aa ed., Independently Published, 2020.</p> </li> <li> <p>MARTIN, R. C., Arquitetura Limpa: o guia do artes\u00e3o para estrutura e design de software, 1\u00aa ed., Alta Books, 2018.</p> </li> <li> <p>PARKER, G. G.; VAN ALSTYNE, M. W.; CHOUDARY, S. P., Plataforma: a revolu\u00e7\u00e3o da estrat\u00e9gia, 1\u00aa ed., Alta Books, 2018.</p> </li> <li> <p>SEHGAL, N. K.; BHATT, P. C. P.; ACKEN J. M., Cloud Computing with Security and Scalability.: Concepts and Practices, 3\u00aa ed., Springer, 2023.</p> </li> <li> <p>KRIEF, M., Learning DevOps: A comprehensive guide to accelerating DevOps culture adoption with Terraform, Azure DevOps, Kubernetes, and Jenkins, 2\u00aa ed., Packt Publishing, 2022.</p> </li> <li> <p>GAMMA, E.; HELM, R.; JOHNSON, R., VLISSIDES, J., Design Patterns: Elements of Reusable Object-Oriented Software, 1\u00aa ed., Addison-Wesley Professional, 1994.</p> </li> <li> <p>SANTANA, E. F. Z., Back-end Java: Microsservi\u00e7os, Spring Boot e Kubernetes, Casa do C\u00f3digo, 2021. Material.</p> </li> <li> <p>SANTANA, E. F. Z., Apache Kafka e Spring Boot: Comunica\u00e7\u00e3o ass\u00edncrona entre microsservi\u00e7os, Casa do C\u00f3digo, 2022. Material.</p> </li> </ol> <p>Artigos:</p> <ul> <li> <p>XU, A. et al.. ByteByteGo - System Design 101. Dispon\u00edvel em: https://github.com/ByteByteGoHq/system-design-101. Acesso em: 19 dezembro 2023.</p> </li> <li> <p>Spring. Spring Cloud. Dispon\u00edvel em: https://spring.io/projects/spring-cloud. Acesso em: 19 dezembro 2023.</p> </li> <li> <p>CHOI, K., Software Engineering Blogs. Dispon\u00edvel em: https://github.com/kilimchoi/engineering-blogs. Acesso em: 20 dezembro 2023.</p> </li> <li> <p>Ghemawat, S. et al.. Towards Modern Development of Cloud Applications.  Proceedings of the 19th Workshop on Hot Topics in Operating Systems, 2023 - p. 110-117. Association for Computing Machinery, Providence, RI, USA. Dispon\u00edvel em: doi:10.1145/3593856.3595909. Acesso em: 05 fevereiro de 2024.</p> </li> </ul>"},{"location":"auth-service/","title":"Auth Service","text":"<p>As the platform has only one entrace point, it is</p> <p>JWT is a decentralized </p> <p>The point of entrance of API is the gateway, then as suggested by <sup>1</sup>.</p>"},{"location":"auth-service/#auth-service","title":"Auth Service","text":"<ul> <li>Responsabilities:<ul> <li>Registration:</li> <li>Authentication:</li> <li>Authorization:</li> </ul> </li> </ul> <p>Two Maven Projects</p> <ul> <li> <p>Interfaces</p> </li> <li> <p>Implemmentation: resource</p> </li> </ul> <pre><code>classDiagram\n  namespace Interface {\n    class AuthController {\n      &lt;&lt;interface&gt;&gt;\n      register(RegisterIn)\n      authenticate(CredentialIn)\n      identify(String)\n    }\n    class RegisterIn {\n      &lt;&lt;record&gt;&gt;\n      String firstName\n      String lastName\n      String email\n      String password\n    }\n    class CredentialIn {\n      &lt;&lt;record&gt;&gt;\n      String email\n      String password\n    }\n  }\n  namespace Resource {\n    class AuthResource {\n      &lt;&lt;REST API&gt;&gt;\n      -authService\n    }\n    class AuthService {\n      &lt;&lt;service&gt;&gt;\n      -registerRepository\n      -userRepository\n      register(Register)\n      authenticate(Credential)\n      identify(Session)\n    }\n    class RegisterRepository {\n      &lt;&lt;interface&gt;&gt;\n    }\n    class RegisterEntity {\n      &lt;&lt;entity&gt;&gt;\n    }\n    class UserRepository {\n      &lt;&lt;interface&gt;&gt;\n    }\n    class UserEntity {\n      &lt;&lt;entity&gt;&gt;\n    }\n  }\n  AuthController &lt;|-- AuthResource\n  AuthResource o-- AuthService\n  AuthService o-- RegisterRepository\n  AuthService o-- UserRepository\n  RegisterRepository \"1\" --&gt; \"0..*\" RegisterEntity\n  UserRepository \"1\" --&gt; \"0..*\" UserEntity</code></pre>"},{"location":"auth-service/#addtional-material","title":"Addtional Material","text":"<ul> <li> <p>JSON Web Token</p> </li> <li> <p>Fernanda Kipper - Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com Spring Security e JWT Tokens</p> <p></p> </li> </ul> <ol> <li> <p>DELANTHA, R., Spring Cloud Gateway security with JWT, 2023.\u00a0\u21a9</p> </li> </ol>"},{"location":"contributors/","title":"Contributors","text":"Name Humberto Sandmann"},{"location":"devops/","title":"Concepts","text":"<p>DevOps is a set of practices that combines software development (Dev) and IT operations (Ops). It aims to shorten the system development life cycle and provide continuous delivery with high software quality. DevOps is complementary with Agile software development; several DevOps aspects came from Agile methodology.</p> <p>Key concepts of DevOps include:</p> <ul> <li>Continuous Integration (CI): Developers regularly merge their code changes into a central repository, after which automated builds and tests are run.</li> <li>Continuous Delivery (CD): The combined practices of continuous integration and automated testing allow for the continuous delivery of code changes to a staging or production system.</li> <li>Infrastructure as Code (IaC): Infrastructure is defined and managed using code and software development techniques, such as version control and continuous integration.</li> <li>Monitoring and Logging: Keeping track of how applications and systems are performing in real-time to understand ongoing IT infrastructure status.</li> <li>Communication and Collaboration: Increased communication and collaboration in an organization is one of the key cultural aspects of DevOps. The use of DevOps tooling and automation of the software delivery process tends to increase collaboration between the teams.</li> </ul> <p> </p> Source: Wikipedia - Devops"},{"location":"devops/#cicd","title":"CI/CD","text":""},{"location":"devops/#pipeline","title":"Pipeline","text":""},{"location":"devops/#service-level-agreement-sla","title":"Service-level agreement - SLA","text":"<p>Service-level agreement, well-known as SLA, is </p>"},{"location":"devops/#other-approaches","title":"Other Approaches","text":""},{"location":"devops/#noops","title":"NoOps","text":"<p>NoOps, short for \"No Operations\", is a concept in software development where the software is designed in such a way that it requires minimal or even no IT operations support. This is often achieved through the use of fully automated processes and systems, which eliminate the need for manual intervention in tasks such as deployment, scaling, and systems management.</p> <p>The goal of NoOps is to allow the software developers to focus on writing new features for the application, rather than spending time on operational concerns. This is often achieved through the use of Platform as a Service (PaaS) providers, which handle many of the operational tasks automatically.</p> <p>https://www.jenkins.io/doc/tutorials/build-a-java-app-with-maven/</p> <p>Install Jenkins on Docker</p> <pre><code>version: '3.8'\nname: infra\n\nservices:\n\n  jenkins:\n    container_name: jenkins\n    build:\n      context: ../infra/\n      dockerfile_inline: |\n        FROM jenkins/jenkins:jdk17\n        USER root\n        RUN apt-get update &amp;&amp; apt-get install -y lsb-release\n        RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \\\n          https://download.docker.com/linux/debian/gpg\n        RUN echo \"deb [arch=$(dpkg --print-architecture) \\\n          signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \\\n          https://download.docker.com/linux/debian \\\n          $(lsb_release -cs) stable\" &gt; /etc/apt/sources.list.d/docker.list\n        RUN apt-get update &amp;&amp; apt-get install -y docker-ce-cli\n        USER jenkins\n        # RUN jenkins-plugin-cli --plugins \"blueocean docker-workflow\"\n    ports:\n      - 9000:8080\n      - 50000:50000\n    volumes:\n      - ./data/jenkins_home:/var/jenkins_home\n    restart: always\n    networks:\n      - private-network\n\nnetworks:\n  private-network:\n    driver: bridge\n</code></pre> <pre><code>docker compose up -d --build\n</code></pre> <p>The will be avaliable at: <pre><code>http://localhost:9000\n</code></pre></p> <p>Jenkins</p> <p>Install plugins: - Blue Ocean - Docker - Docker Pipeline - Kubernetes Cli</p> <p>https://www.jenkins.io/doc/tutorials/build-a-java-app-with-maven/</p> <p>https://www.jenkins.io/blog/2017/02/07/declarative-maven-project/</p> <ol> <li> <p>Wiki Service-level Agreement \u21a9</p> </li> </ol>"},{"location":"docker/","title":"Docker","text":"<p>How to avoid the classical..</p> <p></p> <p>?</p> <p>The answer is: CONTAINERIZATION.</p> <p>Docker is a platform and tool that enables developers to automate the deployment of applications inside lightweight, portable containers. Containers are a form of virtualization that packages an application and its dependencies together, ensuring consistency across different environments, from development to testing and production.</p> <p>Here are some key concepts and components of Docker:</p> <ul> <li>Containerization: Containers are lightweight, standalone, and executable packages that include everything needed to run a piece of software, including the code, runtime, libraries, and system tools. Containers isolate applications from their environment, making them portable and consistent across various systems.</li> <li>Docker Engine: This is the core component of Docker. It is a lightweight and portable runtime that can run containers on various operating systems, including Linux and Windows. The Docker Engine consists of a server, a REST API, and a command-line interface.</li> <li>Docker Image: An image is a lightweight, standalone, and executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files. Images are used to create containers.</li> <li>Dockerfile: A Dockerfile is a text file that contains instructions for building a Docker image. It specifies the base image, sets up the environment, installs dependencies, and configures the application.</li> <li>Registry: Docker images can be stored in registries, which are repositories for sharing and distributing container images. Docker Hub is a popular public registry, and organizations often use private registries to store and manage their proprietary images.</li> <li>Container Orchestration: Docker can be used in conjunction with container orchestration tools like Kubernetes or Docker Swarm to manage the deployment, scaling, and orchestration of containerized applications in production environments.</li> <li>Portability: One of Docker's key advantages is its portability. Since containers encapsulate everything an application needs to run, they can run consistently across different environments, reducing the \"it works on my machine\" problem often encountered in software development.</li> </ul> <p>Docker has become a widely adopted technology in the software development and deployment space due to its ease of use, portability, and the efficiency it brings to the development and deployment lifecycle. It has revolutionized the way applications are packaged, shipped, and deployed, making it easier for developers to build, test, and deploy applications in a more reliable and consistent manner.</p>"},{"location":"docker/#differences-between-docker-and-virtual-machines","title":"Differences between Docker and Virtual Machines","text":"<p>Docker containers and virtual machines (VMs) are both technologies used for virtualization, but they operate at different levels and have distinct characteristics. Here are the key differences between Docker containers and virtual machines:</p> Aspect Docker Containers Virtual Machines Architecture Containers share the host operating system's kernel and isolate the application processes from each other. Each container runs in its own user space but uses the host's kernel. VMs, on the other hand, run a complete operating system, including its own kernel, on top of a hypervisor. Each VM is essentially a full-fledged virtualized computer with its own resources. Resource Efficiency Containers are more lightweight and share the host OS kernel, which makes them more resource-efficient compared to VMs. Containers can start up quickly and consume fewer system resources. VMs have more overhead because each VM requires a full operating system and has its own kernel. This makes VMs less resource-efficient than containers. Isolation Containers provide process-level isolation, meaning that each container runs in its own process space, but they share the same OS kernel. This isolation is generally sufficient for most applications. VMs provide stronger isolation since each VM runs its own operating system and has its own kernel. This makes VMs a better choice in situations where strong isolation is a critical requirement. Portability Containers are highly portable because they encapsulate the application and its dependencies, ensuring consistency across different environments. VMs are less portable due to the larger size and complexity associated with bundling a full operating system with the application. Startup Time Containers can start up very quickly, typically in seconds, making them well-suited for microservices architectures and dynamic scaling. VMs generally have longer startup times, often measured in minutes, due to the time required to boot a full operating system. Resource Utilization Containers share the host OS resources, which can lead to higher density and more efficient resource utilization. VMs have a higher resource overhead because each VM requires its own set of resources, including memory, disk space, and CPU. Use Cases Containers are well-suited for microservices architectures, continuous integration/continuous deployment (CI/CD) pipelines, and scenarios where rapid deployment and scalability are crucial. VMs are suitable for scenarios that require strong isolation, compatibility with various operating systems, and where applications rely on specific OS configurations. <p> </p> Source: Docker vs. Virtual Machines: Differences You Should Know <p>In summary, Docker containers and virtual machines have different levels of abstraction and are suitable for different use cases. Containers are lightweight, portable, and efficient, making them popular for modern application development and deployment practices. Virtual machines provide stronger isolation and are more suitable for scenarios where running multiple instances of different operating systems is necessary. The choice between Docker containers and virtual machines depends on the specific requirements of the application and the environment in which it will be deployed. To install Docker Engine, see Install Docker Engine.</p>"},{"location":"docker/#creating-a-simple-docker","title":"Creating a Simple Docker","text":"Command Description <code>docker run &lt;image&gt;</code> Runs a Docker container from an image. <code>docker ps</code> Lists running Docker containers. <code>docker ps -a</code> Lists all Docker containers, both running and stopped. <code>docker stop &lt;container&gt;</code> Stops a running Docker container. <code>docker rm &lt;container&gt;</code> Removes a Docker container. <code>docker images</code> Lists Docker images. <code>docker rmi &lt;image&gt;</code> Removes a Docker image. <code>docker pull &lt;image&gt;</code> Pulls a Docker image from a Docker registry. <code>docker build -t &lt;tag&gt; .</code> Builds a Docker image from a Dockerfile in the current directory. <code>docker exec -it &lt;container&gt; &lt;command&gt;</code> Executes a command in a running Docker container. <code>docker logs &lt;container&gt;</code> Fetches the logs of a Docker container. <p>Hello Markdown!</p> pip install termynalInstalled <pre><code>FROM openjdk:17-alpine\nVOLUME /tmp\nARG JAR_FILE=target/gateway-0.0.1-SNAPSHOT.jar\nCOPY ${JAR_FILE} app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n</code></pre> <p>https://docs.docker.com/engine/install/</p> <p>https://www.docker.com/blog/how-to-use-your-own-registry-2/</p> <ol> <li> <p>Docker vs. Virtual Machines: Differences You Should Know \u21a9</p> </li> </ol>"},{"location":"gitactions/","title":"GitActions","text":""},{"location":"gitactions/#github-actions","title":"GitHub Actions","text":"<p>GitHub Actions is a feature of GitHub that allows you to automate, customize, and execute your software development workflows right in your repository. </p> <p>With GitHub Actions, you can build, test, and deploy your code directly from GitHub. It provides world-class support for Continuous Integration/Continuous Deployment (CI/CD). </p> <p>In addition, GitHub Actions allows you to automate other aspects of your development workflow such as assigning code reviews, managing branches, and triaging issues.</p>"},{"location":"jwt/","title":"JWT","text":""},{"location":"jwt/#jwt-json-web-token","title":"JWT - JSON Web Token","text":"<p>JWT stands for JSON Web Token. It is a compact, URL-safe means of representing claims between two parties. JWTs are commonly used to secure the transmission of information between parties in a web environment, typically for authentication and information exchange. The JWT specification is defined by RFC 7519<sup>1</sup> and it is a decentralized approach for security (which can support horizontal scalability).</p> <p>Here are the key components and concepts of JWT:</p> <ul> <li>JSON Format: JWTs are represented as JSON objects that are easy to parse and generate. The JSON format makes them human-readable and easy to work with.</li> <li> <p>Three Parts: JWTs consist of three parts separated by dots (<code>.</code>): Header, Payload, and Signature.</p> <ul> <li> <p>Header: The header typically consists of two parts: the type of the token (JWT) and the signing algorithm being used, such as HMAC SHA256 or RSA.</p> </li> <li> <p>Payload: The payload contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims.</p> </li> <li> <p>Signature: To create the signature part, you take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.</p> </li> </ul> </li> <li> <p>Encoding: Each of the three parts is Base64Url encoded, and the resulting strings are concatenated with periods between them. The final JWT looks like: <code>xxxxx.yyyyy.zzzzz</code>.</p> </li> <li>Stateless and Self-contained: JWTs are stateless, meaning that all the information needed is within the token itself. The server doesn't need to store the user's state. They are also self-contained, meaning that all the information needed is contained within the token.</li> <li>Use Cases: JWTs are commonly used for authentication and information exchange between parties. For example, after a user logs in, a server could generate a JWT and send it to the client. The client can then include the JWT in the headers of subsequent requests to access protected resources. The server can verify the authenticity of the JWT using the stored secret key.</li> <li>Security Considerations: While JWTs are widely used and versatile, it's important to handle them securely. For instance, the key used to sign the JWT should be kept secret, and HTTPS should be used to transmit JWTs to prevent man-in-the-middle attacks.</li> </ul> <p>Here's a simple example of a JWT created on JWT Builder<sup>2</sup>:</p> <p><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpc3MiOiJJbnNwZXIiLCJpYXQiOjE3MDMwMDgzMzgsImV4cCI6MjAxODU0MTEzOCwiYXVkIjoid3d3Lmluc3Blci5lZHUuYnIiLCJzdWIiOiJodW1iZXJ0b3JzQGluc3Blci5lZHUuYnIiLCJHaXZlbk5hbWUiOiJIdW1iZXJ0byIsIlN1cm5hbWUiOiJTYW5kbWFubiIsIkVtYWlsIjoiaHVtYmVydG9yc0BpbnNwZXIuZWR1LmJyIiwiUm9sZSI6IlByb2Zlc3NvciJ9.SsGdvR5GbYWTRbxY7IGxHt1vSxhkpRueBJWsi0lrPhJVCICp119QjU8F3QvHW0yF5tw-HhQ9RVh0l89t4M0LNw</code></p> <p>This JWT consists of three parts, decoded by <sup>3</sup>:</p> HeaderPayloadSignature <p><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9</code></p> <pre><code>{\n  \"typ\": \"JWT\",\n  \"alg\": \"HS512\"\n}\n</code></pre> <p><code>eyJpc3MiOiJJbnNwZXIiLCJpYXQiOjE3MDMwMDgzMzgsImV4cCI6MjAxODU0MTEzOCwiYXVkIjoid3d3Lmluc3Blci5lZHUuYnIiLCJzdWIiOiJodW1iZXJ0b3JzQGluc3Blci5lZHUuYnIiLCJHaXZlbk5hbWUiOiJIdW1iZXJ0byIsIlN1cm5hbWUiOiJTYW5kbWFubiIsIkVtYWlsIjoiaHVtYmVydG9yc0BpbnNwZXIuZWR1LmJyIiwiUm9sZSI6IlByb2Zlc3NvciJ9</code></p> <pre><code>{\n  \"iss\": \"Insper\",\n  \"iat\": 1703008338,\n  \"exp\": 2018541138,\n  \"aud\": \"www.insper.edu.br\",\n  \"sub\": \"humbertors@insper.edu.br\",\n  \"GivenName\": \"Humberto\",\n  \"Surname\": \"Sandmann\",\n  \"Email\": \"humbertors@insper.edu.br\",\n  \"Role\": \"Professor\"\n}\n</code></pre> <p><code>SsGdvR5GbYWTRbxY7IGxHt1vSxhkpRueBJWsi0lrPhJVCICp119QjU8F3QvHW0yF5tw-HhQ9RVh0l89t4M0LNw</code></p> <pre><code>HMACSHA512(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  qwertyuiopasdfghjklzxcvbnm123456,\n)\n</code></pre> <p>JWTs are widely used in web development due to their simplicity, flexibility, and support across various programming languages and frameworks. They are commonly used in token-based authentication systems.</p>"},{"location":"jwt/#addtional-material","title":"Addtional Material","text":"<ul> <li> <p>Spring Cloud Security</p> </li> <li> <p>ByeteByteGo - Why is JWT popular?</p> <p></p> </li> </ul> <ol> <li> <p>RFC 7519 - JSON Web Token (JWT), 2015.\u00a0\u21a9</p> </li> <li> <p>JWT - Builder.\u00a0\u21a9</p> </li> <li> <p>jwt.io - JWT Verification.\u00a0\u21a9</p> </li> <li> <p>Unix Time Stamp - Epoch Converter.\u00a0\u21a9</p> </li> <li> <p>DELANTHA, R., Spring Cloud Gateway security with JWT, 2023.\u00a0\u21a9</p> </li> <li> <p>Wikipedia - Pepper (cryptography).\u00a0\u21a9</p> </li> <li> <p>PGzlan, Serve your hash with Salt and Pepper for Stronger Account Security, 2023.\u00a0\u21a9</p> </li> </ol>"},{"location":"kubernetes/","title":"Kubernetes","text":""},{"location":"kubernetes/#kubernetes","title":"Kubernetes","text":"<p>Kubernetes, also known as K8s, is an open-source platform designed to automate deploying, scaling, and operating application containers. It was originally designed by Google and is now maintained by the Cloud Native Computing Foundation.</p> <p>Key features of Kubernetes include:</p> <ul> <li>Service discovery and load balancing: Kubernetes can expose a container using the DNS name or their own IP address. If traffic to a container is high, Kubernetes is able to load balance and distribute the network traffic to help the deployment stable.</li> <li>Storage orchestration: Kubernetes allows you to automatically mount a storage system of your choice, such as local storages, public cloud providers, and more.</li> <li>Automated rollouts and rollbacks: You can describe the desired state for your deployed containers using Kubernetes, and it can change the actual state to the desired state at a controlled rate. For example, you can automate Kubernetes to create new containers for your deployment, remove existing containers and adopt all their resources to the new container.</li> <li>Automatic bin packing: You provide Kubernetes with a cluster of nodes that it can use to run containerized tasks. You tell Kubernetes how much CPU and memory (RAM) each container needs. Kubernetes can fit containers onto your nodes to make the best use of your resources.</li> <li>Self-healing: Kubernetes restarts containers that fail, replaces and reschedules containers when nodes die, kills containers that don\u2019t respond to your user-defined health check, and doesn\u2019t advertise them to clients until they are ready to serve.</li> <li>Secret and configuration management: Kubernetes lets you store and manage sensitive information, such as passwords, OAuth tokens, and SSH keys. You can deploy and update secrets and application configuration without rebuilding your container images, and without exposing secrets in your stack configuration.</li> </ul> <p>https://minikube.sigs.k8s.io/docs/start/</p> <p>https://cloud.google.com/learn/what-is-kubernetes?hl=pt-br#section-4</p> <p>https://serverlessland.com/</p>"},{"location":"messaging/","title":"Concepts","text":"<p>https://medium.com/@thiagolenz/tutorial-spring-boot-e-rabbitmq-como-fazer-e-porqu%C3%AA-4a6cc34a3bd1</p> <p>https://www.simplilearn.com/kafka-vs-rabbitmq-article</p> <p>https://mmarcosab.medium.com/criando-consumer-e-produkafka-com-spring-boot-b427cc2f841d</p>"},{"location":"oauth2/","title":"OAuth2","text":"<p>OAuth2 is an authorization framework that allows applications to obtain limited access to user accounts on an HTTP service, such as Facebook, Google, or GitHub, without exposing the user's credentials. It provides a secure and standardized way for users to grant access to their resources to third-party applications.</p> <p>The principal process to obtain a valid credential using OAuth2 involves the following steps:</p> <ol> <li> <p>Registration: The application developer needs to register their application with the OAuth2 provider (e.g., Google, Facebook) to obtain client credentials, including a client ID and client secret. These credentials are used to identify and authenticate the application.</p> </li> <li> <p>User Authorization: When a user wants to grant access to their resources, the application redirects them to the OAuth2 provider's authorization endpoint. This typically involves the user being presented with a login screen and being asked to grant permission to the application.</p> </li> <li> <p>Authorization Grant: Once the user grants permission, the OAuth2 provider issues an authorization grant to the application. This grant can take various forms, such as an authorization code or an access token.</p> </li> <li> <p>Token Exchange: The application then exchanges the authorization grant for an access token by sending a request to the OAuth2 provider's token endpoint. The access token is a credential that the application can use to access the user's resources on behalf of the user.</p> </li> <li> <p>Accessing Resources: With the access token, the application can make requests to the OAuth2 provider's API endpoints to access the user's resources. The access token is typically included in the request headers or as a query parameter.</p> </li> <li> <p>Refreshing Tokens: Access tokens have a limited lifespan. To continue accessing the user's resources, the application can use a refresh token (if provided) to obtain a new access token without requiring the user to reauthorize the application.</p> </li> </ol> <p>It's important to note that the exact process and terminology may vary slightly depending on the OAuth2 provider and the specific implementation. However, the general flow remains consistent across most OAuth2 implementations.</p>"},{"location":"package/","title":"Package","text":""},{"location":"package/#maven","title":"Maven","text":"<p>Maven uses an XML file to describe the software project being built, its dependencies on other external modules and components, the build order, directories, and required plugins. It comes with pre-defined targets for performing certain well-defined tasks such as compilation of code and its packaging.</p> <p>Key Features: - Simple project setup that follows best practices. - Dependency management including automatic updating, dependency closures (also known as transitive dependencies) - Able to easily work with multiple projects at the same time. - Large and mature community with a large ecosystem of plugins and integrations.</p>"},{"location":"package/#gradle","title":"Gradle","text":"<p>Gradle is another build automation tool that builds upon the concepts of Apache Ant and Apache Maven and introduces a Groovy-based domain-specific language (DSL) instead of the XML form used by Apache Maven for declaring the project configuration. Gradle provides a platform to support the entire development lifecycle of a software project.</p> <p>Key Features: - Declarative builds and build-by-convention. - Language for dependency-based programming. - Structure your build. - Deep API. - Multi-project builds. - Many ways to manage dependencies. - Integration with existing structures. - Ease of migration.</p>"},{"location":"release/","title":"Release","text":""},{"location":"release/#infrastructure-as-code-and-automation-iac","title":"Infrastructure as Code and Automation (IaC)","text":"<p>Infrastructure as Code (IaC) is a method of managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.</p> <p>In other words, IaC is the process of managing and provisioning computer data centers through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.</p> <p>The IT infrastructure managed by this comprises both physical equipment such as bare-metal servers as well as virtual machines and associated configuration resources. The definitions may be in a version control system. It can use either scripts or declarative definitions, rather than manual processes, but the term is more often used to promote declarative approaches.</p> <p>IaC approaches are promoted for cloud computing, which is sometimes marketed as Infrastructure as a Service (IaaS). IaC supports IaaS, but should not be confused with it.</p> <p>Jenkins DSL (Domain Specific Language)</p>"},{"location":"release/#jenkins","title":"Jenkins","text":"<p>Installing Jenkins</p> <p>SDLC - Software Development LifeCycle</p>"},{"location":"release/#service-level-agreement-sla","title":"Service-level agreement - SLA","text":"<p>Service-level agreement, well-known as SLA, is</p> <p>References:</p> <pre><code>-[Wiki Service-level Agreement](https://en.wikipedia.org/wiki/Service-level_agreement)\n</code></pre>"},{"location":"security/","title":"Concepts","text":""},{"location":"security/#security","title":"Security","text":"<p>Security is an important aspect of software development. It involves protecting the confidentiality, integrity, and availability of data and resources. Two key concepts in security are authentication and authorization.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>Authentication is the process of verifying the identity of a user or system. It ensures that the user or system is who they claim to be. Common authentication methods include passwords, biometrics, and two-factor authentication. The system checks these credentials against the stored data. If the credentials are valid, the system confirms the user's identity.</p> <p>In many systems, after successful authentication, the system generates a token. This token is a piece of data that represents the user's authentication session. It's like a digital ticket that proves the user's identity for a certain period of time.</p> <p>This token is then sent back to the user. The user's client software (like a web browser) stores this token and sends it along with every subsequent request to the server (in case of stateless server). This way, the server knows that the request comes from an authenticated user without needing to ask for the credentials again.</p> <p>Here's a simplified step-by-step process:</p> <pre><code>sequenceDiagram\n  autonumber\n  actor User\n  User-&gt;&gt;+Auth Server: authentication(credentials)\n  Auth Server-&gt;&gt;Auth Server: verifies credenditals and generates a token\n  Auth Server-&gt;&gt;-User: returns the token\n  User-&gt;&gt;User: stores the token to use for the next requests</code></pre> <ol> <li>The user sends their username and password (or other credentials) to the server;</li> <li>The server verifies the credentials. If they're valid, the server generates a token.</li> <li>The server sends this token back to the user.</li> <li>The user's client software stores this token.</li> <li>For every subsequent request, the client sends this token along with the request.</li> <li>The server checks the token to ensure it's valid and hasn't expired.</li> <li>This token-based authentication process is commonly used in many modern web applications and APIs. It helps maintain the user's session and allows the server to authenticate requests without storing the user's state.</li> </ol>"},{"location":"security/#authorization","title":"Authorization","text":"<p>Authorization is the process of granting or denying access to specific resources or actions based on the authenticated user's privileges. It determines what a user is allowed to do within a system. Authorization can be role-based, where permissions are assigned based on predefined roles, or attribute-based, where permissions are based on specific attributes of the user.</p> <p>In many systems, the token not only represents the user's identity, but also includes information about their permissions or roles. This is often done using a type of token called a JSON Web Token (JWT), which can include a payload of data.</p> <p>Here's a simplified step-by-step process:</p> <pre><code>sequenceDiagram\n  autonumber\n  actor User\n  User-&gt;&gt;Auth Server: request with token\n  Auth Server-&gt;&gt;Auth Server: decodes the token and extracts claims\n  Auth Server-&gt;&gt;Auth Server: verifies permissions\n  critical allowed\n    Auth Server-&gt;&gt;Secured Resource: authorizes the request\n    Secured Resource-&gt;&gt;User: returns the response\n  option denied\n    Auth Server--&gt;&gt;User: unauthorized message\n  end  </code></pre> <ol> <li>After authentication, the user's client software sends a request to a server. This request includes the token.</li> <li>The server decodes the token and extracts the user's identity and permissions.</li> <li>The server checks whether the user has the necessary permissions for the requested action. This could involve checking the user's roles or other attributes against the requirements for the action.</li> <li>If the user has the necessary permissions, the server allows the action. If not, the server denies the action.</li> </ol> <p>This process allows the server to authorize actions without needing to repeatedly look up the user's permissions. It also allows for stateless servers, as the necessary information is included in every request.</p> <p>By implementing strong authentication and authorization mechanisms, software systems can ensure that only authorized users have access to sensitive data and functionalities, reducing the risk of unauthorized access and potential security breaches.</p>"},{"location":"terraform/","title":"Terraform","text":""},{"location":"terraform/#infrastructure-as-code-iac","title":"Infrastructure as Code (IaC)","text":"<p>Infrastructure as Code (IaC) is a method of managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools. </p> <p>The IT infrastructure managed by this comprises both physical equipment, such as bare-metal servers, as well as virtual machines, and associated configuration resources. The definitions may be in a version control system. It can use either scripts or declarative definitions, rather than manual processes, but the term is more often used to promote declarative approaches.</p>"},{"location":"terraform/#pros","title":"Pros","text":"<ul> <li>Automatization of creation of an infrastructure;</li> <li>Standardization of platforms;</li> <li>Replication of infrastructure.</li> </ul> <pre><code>|- .github\n|  |- workflows\n|- s3-bucket-static\n   |- main.tf\n</code></pre> main.tf<pre><code>provider \"aws\" {\n    region = \"us-east-1\"\n}\n\nvariable \"bucket_name\" {\n    type = string\n}\n\nresource \"aws_s3_bucket\" \"static_site_bucket\" {\n    bucket = \"static-site-${var.bucket_name}\"\n\n    website {\n        index_document = \"index.html\"\n        error_document = \"404.html\n    }\n\n    tags = {\n        Name = \"Static Site Bucket\"\n        Environment = \"Production\"\n    }\n}\n\nresource \"aws_s3_public_access_block\" \"static_site_bucket\" {\n    bucket aws_s3_bucket.static_site_bucket.id\n\n    block_public_acls       = false\n    block_public_policy     = false\n    ignore_public_acls      = false\n    restrict_public_buckets = false\n}\n</code></pre>"},{"location":"terraform/#alternatives","title":"Alternatives","text":"<ul> <li>AWS CloudFormation</li> <li>Ansible</li> <li>Vagrant</li> </ul>"},{"location":"terraform/#additional-material","title":"Additional Material","text":"<ul> <li> <p>Fernanda Kipper - Criando Infra na AWS com Terraform (IaC)</p> <p></p> </li> </ul>"},{"location":"version-control-system/","title":"Version Control","text":""},{"location":"version-control-system/#git","title":"Git","text":"<p>Git is a distributed version control system designed to handle everything from small to very large projects with speed and efficiency. It was created by Linus Torvalds in 2005 for development of the Linux kernel.</p> <p>Key features of Git include:</p> <ul> <li>Distributed Version Control: This means that every user has a complete copy of the project repository on their local machine. This allows for operations to be performed offline and provides a backup in case the central repository fails.</li> <li>Branching and Merging: Git's branching model allows developers to work on different features or bugs in isolation, without affecting the main codebase. These branches can then be merged back into the main codebase when the work is complete.</li> <li>Speed: Git is designed to be fast and efficient, even for large projects.</li> <li>Data Integrity: Git uses a data model that ensures the cryptographic integrity of every bit of your project. Every file and commit is checksummed and retrieved by its checksum when checked back out.</li> <li>Staging Area: Git provides a staging area or \"index\" that allows you to format and review your commits before completing the commit.</li> </ul> <p>SCM - Supply-chain-management software</p> <p>https://twitter.com/milan_milanovic/status/1745435542127349899</p>"},{"location":"api/documentation/","title":"Documentation","text":""},{"location":"api/documentation/#swagger","title":"Swagger","text":"mavengradle <pre><code>&lt;dependency&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>\n</code></pre> <p>```javascript I'm A tab console.log('Code Tab A'); <pre><code>```javascript I'm tab B\nconsole.log('Code Tab B');\n</code></pre></p> CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre> <p>https://www.baeldung.com/spring-rest-openapi-documentation</p>"},{"location":"api/spring-boot-cloud/","title":"Spring Boot Cloud","text":"<p>Containering:</p> <p>https://spring.io/projects/spring-cloud/</p> <p>https://github.com/spring-cloud/spring-cloud-release/wiki/Supported-Versions</p>"},{"location":"appendix/rest-vs-graphql/","title":"REST vs GraphQL","text":"Source: System Design 101 - REST API vs. GraphQL <ol> <li> <p>XU, A., System Design 101.\u00a0\u21a9</p> </li> <li> <p>Wikipedia - REST.\u00a0\u21a9</p> </li> <li> <p>Wikipedia - GraphQL.\u00a0\u21a9</p> </li> </ol>"},{"location":"appendix/tls-for-microservices/","title":"TLS for microservices","text":"<p>Let's Encrypt</p>"},{"location":"appendix/versioning-rest-apis/","title":"Versioning REST API","text":"<ol> <li> <p>Jacky, Versioning RESTful APIs with Spring Boot: A Step-by-Step Guide in 5 minutes.\u00a0\u21a9</p> </li> </ol>"},{"location":"handout/microservice-account/","title":"Account","text":""},{"location":"handout/microservice-account/#endpoints","title":"Endpoints","text":"<p>Microsservi\u00e7o para gerenciamento de contas.</p>"},{"location":"handout/microservice-account/#create","title":"CREATE","text":"<p><pre><code>POST /accounts\n</code></pre> Request <pre><code>{\n    \"name\": \"Antonio do Estudo\",\n    \"email\": \"acme@insper.edu.br\",\n    \"password\": \"123@\"\n}\n</code></pre> Response</p> code body 201 <code>{ \"id\": \"45d16201-12a4-48bf-8c84-df768fdc4878\", \"name\": \"Antonio do Estudo\", \"email\": \"acme@insper.edu.br\" }</code> 401"},{"location":"handout/microservice-account/#read","title":"READ","text":"<p><pre><code>GET /accounts\n</code></pre> Response</p> code body 200 <code>{ \"id\": \"45d16201-12a4-48bf-8c84-df768fdc4878\", \"name\": \"Antonio do Estudo\", \"email\": \"acme@insper.edu.br\" }</code> 401"},{"location":"handout/microservice-account/#class-diagram","title":"Class Diagram","text":"<p>Exemplo para o microsservi\u00e7o Account.</p> <pre><code>classDiagram\n  namespace Interface {\n    class AccountController {\n      &lt;&lt;interface&gt;&gt;\n      create(AccountIn)\n      read(String id): AccountOut\n      update(String id, AccountIn)\n      delete(String id)\n      findByEmailAndPassword(AccountIn)\n    }\n    class AccountIn {\n      &lt;&lt;record&gt;&gt;\n      String name\n      String email\n      String password\n    }\n    class AccountOut {\n      &lt;&lt;record&gt;&gt;\n      String id\n      String name\n      String email\n    }\n  }\n  namespace Resource {\n    class AccountResource {\n      &lt;&lt;REST API&gt;&gt;\n      -accountService\n    }\n    class AccountService {\n      &lt;&lt;service&gt;&gt;\n      -accountRepository\n      create(Account)\n    }\n    class AccountRepository {\n      &lt;&lt;nterface&gt;&gt;\n      findByEmailAndHash(String, String)\n    }\n    class AccountModel {\n      &lt;&lt;entity&gt;&gt;\n      String id\n      String name\n      String email\n      String hash\n    }\n    class Account {\n      &lt;&lt;dto&gt;&gt;\n      String id\n      String name\n      String email\n      String password\n    }\n  }\n  AccountController &lt;|-- AccountResource\n  AccountResource o-- AccountService\n  AccountService o-- AccountRepository</code></pre>"},{"location":"handout/microservice-account/#pom-dependecy","title":"POM dependecy","text":"<p>Note que esse microsservi\u00e7o possui depend\u00eancia da interface, o Account. Logo, se torna necess\u00e1rio explicitar essa depend\u00eancia no <code>pom.xml</code> do microsservi\u00e7o Account.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;insper.store&lt;/groupId&gt;\n  &lt;artifactId&gt;account&lt;/artifactId&gt;\n  &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"handout/microservice-auth/","title":"Auth","text":""},{"location":"handout/microservice-auth/#endpoints","title":"Endpoints","text":"<p>A fim do sistema possuir um controle de acesso, \u00e9 conveniente a cria\u00e7\u00e3o de um microsservi\u00e7o Auth, que ser\u00e1 respons\u00e1vel pelo cadastro de usu\u00e1rios do sistema. Tal microsservi\u00e7o pode ter, ao menos, os seguintes endpoints:</p>"},{"location":"handout/microservice-auth/#registro","title":"Registro","text":"<p><pre><code>POST /auth/register\n</code></pre> Request <pre><code>{\n    \"name\": \"Antonio do Estudo\",\n    \"email\": \"acme@insper.edu.br\",\n    \"password\": \"123@\"\n}\n</code></pre> Response</p> code body 201 <code>{ \"id\": \"45d16201-12a4-48bf-8c84-df768fdc4878\" }</code>"},{"location":"handout/microservice-auth/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>POST /auth/register\n</code></pre> <pre><code>sequenceDiagram\nautonumber\nactor User\nUser-&gt;&gt;+Auth: register(RegisterIn)\nAuth-&gt;&gt;+Account: create(AccountIn)\nAccount-&gt;&gt;-Auth: returns the new account (AccountOut)\nAuth-&gt;&gt;-User: returns 201</code></pre>"},{"location":"handout/microservice-auth/#autenticacao","title":"Autentica\u00e7\u00e3o","text":"<p><pre><code>POST /auth/login\n</code></pre> Request <pre><code>{\n    \"email\": \"acme@insper.edu.br\",\n    \"password\": \"123@\"\n}\n</code></pre> Response</p> code body 201 <code>{ \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0NWQxNjIwMS0xMmE0LTQ4YmYtOGM4NC1kZjc2OGZkYzQ4NzgiLCJuYW1lIjoiQW50b25pbyBkbyBFc3R1ZG8iLCJpYXQiOjE1MTYyMzkwMjIsInJvbGUiOiJyZWd1bGFyIn0.8eiTZjXGUFrseBP5J91UdDctw-Flp7HP-PAp1eO8f1M\" }</code> 403"},{"location":"handout/microservice-auth/#sequence-diagram_1","title":"Sequence Diagram","text":"<pre><code>POST /auth/login\n</code></pre> <pre><code>sequenceDiagram\nautonumber\nactor User\nUser-&gt;&gt;+Auth: authenticate(CredentiaIn)\nAuth-&gt;&gt;+Account: login(LoginIn)\ncritical validated\n    Account-&gt;&gt;-Auth: returns the account\noption denied\n    Auth--&gt;&gt;User: unauthorized message\nend  \nAuth-&gt;&gt;Auth: generates a token\nAuth-&gt;&gt;-User: returns the token\nUser-&gt;&gt;User: stores the token to use for the next requests</code></pre>"},{"location":"handout/microservice-auth/#class-diagram","title":"Class Diagram","text":"<p>Exemplo para o microsservi\u00e7o Auth.</p> <pre><code>classDiagram\n  namespace Interface {\n    class AuthController {\n      &lt;&lt;interface&gt;&gt;\n      register(RegisterIn)\n      authenticate(CredentialIn): LoginOut\n    }\n    class RegisterIn {\n      &lt;&lt;record&gt;&gt;\n      String name\n      String email\n      String password\n    }\n    class CredentialIn {\n      &lt;&lt;record&gt;&gt;\n      String email\n      String password\n    }\n  }\n  namespace Resource {\n    class AuthResource {\n      &lt;&lt;REST API&gt;&gt;\n      -authService\n    }\n    class AuthService {\n      &lt;&lt;service&gt;&gt;\n      register(RegisterIn)\n      authenticate(CredentialIn)\n    }\n  }\n  AuthController &lt;|-- AuthResource\n  AuthResource o-- AuthService</code></pre>"},{"location":"handout/microservice-auth/#exemplo-de-uma-implementacao-da-interface-authcontroller","title":"Exemplo de uma implementa\u00e7\u00e3o da interface AuthController","text":"<pre><code>package store.auth;\n\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\n\n@FeignClient(\"store-auth\")\npublic interface AuthController {\n\n    @PostMapping(\"/auth/register\")\n    ResponseEntity&lt;?&gt; create (\n        @RequestBody(required = true) RegisterIn in\n    );\n\n    @PostMapping(\"/auth/login\")\n    ResponseEntity&lt;LoginOut&gt; authenticate (\n        @RequestBody(required = true) Credential in\n    );\n}\n</code></pre>"},{"location":"handout/microservice-auth/#pom-dependecy","title":"POM dependecy","text":"<p>Note que esse microsservi\u00e7o possui depend\u00eancia de outro, o Account, al\u00e9m da depend\u00eancia da interface do pr\u00f3prio microsservi\u00e7o. Logo, se torna necess\u00e1rio explicitar essa depend\u00eancia no <code>pom.xml</code> do microsservi\u00e7o Auth.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;insper.store&lt;/groupId&gt;\n  &lt;artifactId&gt;auth&lt;/artifactId&gt;\n  &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;insper.store&lt;/groupId&gt;\n  &lt;artifactId&gt;account&lt;/artifactId&gt;\n  &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"handout/microservice-auth/#nice-to-have","title":"NICE TO HAVE","text":"<p>o projeto da disciplina pode ter um microsservi\u00e7o de registro que valide email ou SMS para criar a conta.</p>"},{"location":"handout/roadmap/","title":"Roadmap","text":""},{"location":"handout/roadmap/#microsservicos","title":"Microsservi\u00e7os","text":"<p>A fim de implementar microsservi\u00e7os em Spring Boot, aqui, \u00e9 proposto uma abordagem de modulariza\u00e7\u00e3o de cada microsservi\u00e7o, de forma que exista uma interface de comunica\u00e7\u00e3o Java a ser consumida por outros microsservi\u00e7os, tamb\u00e9m em Java, e tamb\u00e9m um compromisso de implementa\u00e7\u00e3o. Essa estrat\u00e9gia visa aumentar a produtividade do ambiente de desenvolvimento em Java, j\u00e1 que para o consumo da API por outros frameworks sempre ser\u00e1 necess\u00e1rio reescrever as assinaturas de cada endpoint.</p>"},{"location":"handout/roadmap/#modularizacao","title":"Modulariza\u00e7\u00e3o","text":"<p>Crie dois projetos Mavens:</p> <ul> <li>um de interface, e;</li> <li>outro para o micro servi\u00e7o.</li> </ul> <p>A vantagem dessa abordagem \u00e9 que a interface pode ser utilizada em outros projetos como uma biblioteca a ser consumida.</p> <p>Exemplo de uso dessa abordagem no microsservi\u00e7o Account:</p> <pre><code>classDiagram\n  namespace Interface {\n    class AccountController {\n      &lt;&lt;interface&gt;&gt;\n      create(AccountIn)\n      read(String id): AccountOut\n      update(String id, AccountIn)\n      delete(String id)\n      findByEmailAndPassword(AccountIn)\n    }\n    class AccountIn {\n      &lt;&lt;record&gt;&gt;\n      String name\n      String email\n      String password\n    }\n    class AccountOut {\n      &lt;&lt;record&gt;&gt;\n      String id\n      String name\n      String email\n    }\n  }\n  namespace Resource {\n    class AccountResource {\n      &lt;&lt;REST API&gt;&gt;\n      -accountService\n    }\n    class AccountService {\n      &lt;&lt;service&gt;&gt;\n      -accountRepository\n      create(Account)\n    }\n    class AccountRepository {\n      &lt;&lt;nterface&gt;&gt;\n      findByEmailAndHash(String, String)\n    }\n    class AccountModel {\n      &lt;&lt;entity&gt;&gt;\n      String id\n      String name\n      String email\n      String hash\n    }\n    class Account {\n      &lt;&lt;dto&gt;&gt;\n      String id\n      String name\n      String email\n      String password\n    }\n  }\n  AccountController &lt;|-- AccountResource\n  AccountResource o-- AccountService\n  AccountService o-- AccountRepository</code></pre>"},{"location":"handout/roadmap/#interface","title":"Interface","text":"<p>Para compilar e instalar a interface do microsservi\u00e7o, crie um <code>pom.xml</code> espec\u00edfico para essa interface e seus dtos (AccountIn e AccountOut).</p> Installing the microservice interface<pre><code>mvn clean install\n</code></pre>"},{"location":"handout/roadmap/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o n\u00e3o precisa ser instalada como biblioteca do reposit\u00f3rio Maven, pois \u00e9 apenas para execu\u00e7\u00e3o do microsservi\u00e7o. Por\u00e9m, o microsservi\u00e7o deve ter explic\u00edto a chamada da biblioteca de interface no seu <code>pom.xml</code>.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;insper.store&lt;/groupId&gt;\n  &lt;artifactId&gt;account&lt;/artifactId&gt;\n  &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>O comando para empacotar o microsservi\u00e7o \u00e9:</p> Packaging the microservice<pre><code>mvn clean package\n</code></pre> <p>Adicionalmente, para executar o microsservi\u00e7o:</p> Packaging and running the microservice<pre><code>mvn clean package spring-boot:run\n</code></pre>"},{"location":"handout/roadmap/#banco-de-dados","title":"Banco de dados","text":"<p>Muitos microsservi\u00e7os podem persistir seus dados em banco de dados. Cada microsservi\u00e7o \u00e9 respons\u00e1vel pelo acesso e grava\u00e7\u00e3o de seus dados de forma aut\u00f4noma.</p> <p>Isso aumenta de forma significativa a complexidade do gerenciamento do microsservi\u00e7o, pois se torna necess\u00e1rio manter o gerenciamento da base de dados tais como: altera\u00e7\u00f5es, vers\u00f5es e roteiros de retornos.</p> <p>O Flyway \u00e9 uma biblioteca que pode ser acoplado ao framework Spring Boot a fim de ajudar na tarefa de gerenciamento e cria\u00e7\u00e3o do sistema de persit\u00eancia dos dados do microsservi\u00e7o.</p> <p>Para fazer uso dessa biblioteca, altere o <code>pom.xml</code> adicionando a depend\u00eancia da biblioteca JPA assim bem como a depend\u00eancia da biblioteca Flyway.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;\n    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;\n    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n    &lt;version&gt;42.7.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Altera\u00e7\u00f5es no arquivo de propriedades tamb\u00e9m s\u00e3o necess\u00e1rias, para definir o banco de dados e sua configura\u00e7\u00e3o JPA, assim bem como, a configura\u00e7\u00e3o do Flyway.</p> Exemplo baseado no microsservi\u00e7o Account<pre><code>spring:\n  datasource:\n    url: ${DATABASE_URL:jdbc:postgresql://localhost:5432/store}\n    username: ${DATABASE_USERNAME:store}\n    password: ${DATABASE_PASSWORD:store123321}\n    driver-class-name: org.postgresql.Driver\n  flyway:\n    baseline-on-migrate: true\n    schemas: account\n  jpa:\n    properties:\n      hibernate:\n        default_schema: account\n</code></pre> <p>A estrutura de organiza\u00e7\u00e3o e execu\u00e7\u00e3o de scripts de banco de dados do Flyway \u00e9 persistido na seguinte hier\u00e1rquia de diret\u00f3rios, onde cada arquivo \u00e9 executado em ordem alfanum\u00e9rica.</p> exemplo<pre><code>\ud83d\udcc4 store.account\n\ud83d\udcc1 store.account-resource\n\u2514\u2500\u2500 \ud83d\udcc1 src\n    \u2514\u2500\u2500 \ud83d\udcc1 main\n        \u251c\u2500\u2500 \ud83d\udcc4 java\n        \u2514\u2500\u2500 \ud83d\udcc1 resources\n            \u251c\u2500\u2500 \ud83d\udcc1 db\n            \u2502   \u2514\u2500\u2500 \ud83d\udcc1 migration\n            \u2502       \u251c\u2500\u2500 \ud83d\udcc4 V2024.02.16.001__create_schema.sql\n            \u2502       \u2514\u2500\u2500 \ud83d\udcc4 V2024.02.16.002__create_table_account.sql\n            \u2514\u2500\u2500 \ud83d\udcc4 application.yaml\n</code></pre> V2024.02.16.001__create_schema.sqlV2024.02.16.002__create_table_account.sql <pre><code>CREATE SCHEMA IF NOT EXISTS account;\n</code></pre> <pre><code>CREATE TABLE account\n(\n    id_account character varying(36) NOT NULL,\n    tx_name character varying(256) NOT NULL,\n    tx_email character varying(256) NOT NULL,\n    tx_hash character varying(256) NOT NULL,\n    CONSTRAINT account_pkey PRIMARY KEY (id_account)\n);\n</code></pre>"},{"location":"handout/roadmap/#conectando-microsservicos-openfeign","title":"Conectando Microsservi\u00e7os - OpenFeign","text":"<p>Nomeando o microsservi\u00e7o dentro do sistema de discovery.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>@FeignClient(name = \"spkio-account\")\npublic interface AccountController {\n  ...\n}\n</code></pre>"},{"location":"handout/roadmap/#docker","title":"Docker","text":"<p>Para cada microsservi\u00e7o Java Spring Cloud \u00e9 aconselh\u00e1vel criar um arquivo <code>Dockerfile</code> no diret\u00f3rio raiz do projeto a fim de permitir a cria\u00e7\u00e3o adequada da imagem do microservi\u00e7o.</p> Typical Dockerfile for Java microservice<pre><code>FROM openjdk:23-slim\nVOLUME /tmp\nCOPY target/*.jar app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n</code></pre>"},{"location":"handout/roadmap/#docker-compose","title":"Docker Compose","text":"<p>O Docker Compose permite criar um cluster com todos os microsservi\u00e7os neces\u00e1rios para o funcionamento de um sistema em uma rede apartada (nat).</p> <p>Para criar um docker compose basta criar um arquivo de configura\u00e7\u00e3o chamado <code>docker-compose.yaml</code> em uma pasta que possa acessar os demais microsservi\u00e7os, como uma pasta store.docker-platform.</p> exemplo<pre><code>\ud83d\udcc4 store.account\n\ud83d\udcc4 store.account-resource\n\ud83d\udcc1 store.docker-platform\n\u251c\u2500\u2500 \ud83d\udcc4 .env\n\u2514\u2500\u2500 \ud83d\udcc4 docker-compose.yaml\n</code></pre> <p>Dentro do arquivo, cada microsservi\u00e7o \u00e9 declarado e configurado, utilizando imagem que s\u00e3o criadas no momento de execu\u00e7\u00e3o do docker engine ou imagens que est\u00e3o dispon\u00edveis em algum diret\u00f3rio (eg.: DockerHub).</p> docker-compose.yaml<pre><code># docker compose up -d --build --force-recreate\nversion: '3.8'\nname: store\n\nservices:\n\n  db-store:\n    container_name: store-db-store\n    image: postgres:latest\n    ports:\n      - 5432:5432\n    environment:\n      - POSTGRES_USER=store\n      - POSTGRES_PASSWORD=store\n      - POSTGRES_DB=store\n    volumes:\n      - $VOLUME/postgres/store/data:/var/lib/postgresql/data\n    restart: always\n    networks:\n      - private-network\n\n  account:\n    build:\n      context: ../store.account-resource/\n      dockerfile: Dockerfile\n    image: store-account:latest\n    environment:\n      - spring.datasource.url=jdbc:postgresql://store-db-store:5432/store\n      - spring.datasource.username=store\n      - spring.datasource.password=store\n    deploy:\n      mode: replicated\n      replicas: 1\n    restart: always\n    networks:\n      - private-network\n    depends_on:\n      - db-store\n\nnetworks:\n  private-network:\n    driver: bridge\n</code></pre> <p>Arquivo de configura\u00e7\u00e3o de ambiente.</p> .env<pre><code>VOLUME=./volume\nCONFIG=./config\n</code></pre> <p>Na pasta do arquivo <code>docker-compose.yaml</code> execute o comando docker para criar as imagens e subir os containers:</p> Rise up a cluster<pre><code>docker compose up -d --build\n</code></pre> Shutdown the cluster<pre><code>docker compose down\n</code></pre> <p>Referencia:</p>"},{"location":"platform/circuit-breaker/","title":"Circuit Breaker","text":""},{"location":"platform/circuit-breaker/#spring-cloud-circuit-breaker","title":"Spring Cloud Circuit Breaker","text":"<p>Spring Cloud Circuit Breaker is a service resilience pattern that allows you to provide default behavior when a network failure or any exception occurs while invoking a remote service. It's an abstraction over various circuit breaker implementations like Netflix Hystrix, Resilience4j, Sentinel, etc.</p> <p>Key components of Spring Cloud Circuit Breaker include:</p> <ul> <li> <p>Dependency: To use Spring Cloud Circuit Breaker, you need to include the <code>spring-cloud-starter-circuitbreaker-{implementation}</code> dependency in your project, where <code>{implementation}</code> could be <code>hystrix</code>, <code>resilience4j</code>, <code>sentinel</code>, etc.</p> </li> <li> <p>Configuration: You can configure the circuit breaker parameters like failure threshold, delay time, etc. in the application.properties (or application.yml) file.</p> </li> <li> <p>Usage: You can use the <code>@CircuitBreaker</code> annotation on a method to apply the circuit breaker pattern. If the method throws an exception, the circuit breaker will open and provide a fallback method.</p> </li> </ul>"},{"location":"platform/communcation/","title":"Communication","text":""},{"location":"platform/communcation/#synchronous-communication","title":"Synchronous Communication","text":""},{"location":"platform/communcation/#feign","title":"Feign","text":""},{"location":"platform/communcation/#asynchronous-communication","title":"Asynchronous Communication","text":""},{"location":"platform/communcation/#webclient","title":"WebClient","text":""},{"location":"platform/concept/","title":"Concepts","text":""},{"location":"platform/concept/#historical-context","title":"Historical Context","text":""},{"location":"platform/concept/#single-block-system","title":"Single block system","text":"<p>Single block system, following the concept that a system is a blackbox schema, so many projects started in a simple single project that is a good choice to raise a system and try to use the initial features. This is a good approach for small and compact systems or for specialist systems where the speed of application matters.</p> <pre><code>---\ntitle: blackbox\n---\nflowchart LR\n  Input\n  subgraph Processing\n    direction TB\n    Storage\n    Business\n    UI\n  end\n  Output\n  Input --&gt; UI --&gt; Output</code></pre> <p>The main disadvantage of this approach is the strong coupling among business, user interface (UI), and storage. The coupling is so strong that there is a mix among all the components, which implies a high cost for maintenance.</p>"},{"location":"platform/concept/#splitted-betweeen-data-and-program","title":"Splitted betweeen data and program","text":"<pre><code>---\ntitle: blackbox\n---\nflowchart LR\n  subgraph Processing\n    direction TB\n    subgraph Storage\n      x\n    end\n    subgraph Business\n      UI\n    end\n  end\n  Input --&gt; UI --&gt; Output\n  Business &lt;-- driver --&gt; Storage</code></pre> <p>System communicates to only an UI.</p> <p>Cobol</p>"},{"location":"platform/concept/#multi-layer-approach","title":"Multi-layer approach","text":"<pre><code>---\ntitle: blackbox\n---\nflowchart LR\n  Input\n  subgraph Processing\n    direction TB\n    Storage\n    subgraph _\n      Businesses\n      UI\n    end\n  end\n  Output\n  Input --&gt; UI --&gt; Output\n  Business &lt;-- driver --&gt; Storage</code></pre>"},{"location":"platform/concept/#mvc-pattern","title":"MVC Pattern","text":"<p>MVC stands for Model-View-Controller. It's a design pattern often used in web development. Here's a brief explanation of each component:</p> <ol> <li> <p>Model: This is the part of the system that handles the logic for the application data. Often model objects retrieve data (and store data) from a database.</p> </li> <li> <p>View: This is the part of the system that handles the display of the data. Most often the views are created from the model data.</p> </li> <li> <p>Controller: This is the part of the system that handles user interaction. Typically controllers read data from a view, control user input, and send input data to the model.</p> </li> </ol> <p>The idea behind MVC is that each of these components can be developed and tested independently, which can simplify the overall development process.</p> <pre><code>timeline\n    title Relevant Events\n    1991 : CORBA\n    1994 : GoF\n    1999 : J2EE 1.2 &lt;br&gt; initial specification\n    2002 : Spring\n    2006 : Java EE 5\n    2014 : Spring Boot\n    2019 : Jakarta EE 8</code></pre>"},{"location":"platform/concept/#high-perfomance-architectures","title":"High-perfomance Architectures","text":"<p>High-performance architectures refer to the design and configuration of computer systems, networks, and software to achieve optimal speed, responsiveness, throughput, and efficiency. These architectures are specifically tailored to handle large-scale, resource-intensive, and performance-critical workloads. High-performance systems are often employed in scenarios such as data centers, cloud computing environments, scientific computing, financial services, and other applications where speed and efficiency are paramount.</p> <p>Here are key aspects and principles associated with high-performance architectures:</p>"},{"location":"platform/concept/#parallelism-and-concurrency","title":"Parallelism and Concurrency","text":"<ul> <li>High-performance architectures often leverage parallelism and concurrency to execute multiple tasks simultaneously, improving overall throughput.</li> <li>Parallel processing involves dividing a task into smaller sub-tasks that can be processed concurrently, often across multiple processors or cores.</li> <li>Concurrency allows multiple tasks to be executed concurrently, even if they are not divided into explicit sub-tasks.</li> </ul>"},{"location":"platform/concept/#distributed-systems","title":"Distributed Systems","text":"<ul> <li>Distributing workloads across multiple nodes in a network is a common strategy for achieving high performance.</li> <li>Distributed systems allow for horizontal scaling, where additional resources (nodes) can be added to handle increased demand.</li> </ul>"},{"location":"platform/concept/#optimized-algorithms-and-data-structures","title":"Optimized Algorithms and Data Structures","text":"<ul> <li>Carefully designed algorithms and data structures are crucial for high performance.</li> <li>Efficient algorithms and data structures minimize computational complexity and memory usage.</li> </ul>"},{"location":"platform/concept/#caching-and-memory-optimization","title":"Caching and Memory Optimization","text":"<ul> <li>Caching is used to store frequently accessed data in a location that allows faster retrieval, reducing the need to recompute or fetch data from slower storage.</li> <li>Memory optimization involves efficiently managing memory usage to minimize latency and improve responsiveness.</li> </ul>"},{"location":"platform/concept/#scalability","title":"Scalability","text":"<ul> <li>High-performance architectures are designed to scale horizontally or vertically to accommodate growing workloads.</li> <li>Horizontal scalability involves adding more nodes or machines, while vertical scalability involves increasing the resources of individual nodes.</li> </ul>"},{"location":"platform/concept/#load-balancing","title":"Load Balancing","text":"<ul> <li>Load balancing ensures that incoming requests are distributed evenly across multiple servers or resources.</li> <li>This helps prevent individual components from becoming bottlenecks and ensures optimal resource utilization.</li> </ul>"},{"location":"platform/concept/#fault-tolerance-and-redundancy","title":"Fault Tolerance and Redundancy","text":"<ul> <li>High-performance architectures often incorporate redundancy and fault-tolerant mechanisms to ensure continuous operation in the face of hardware failures or network issues.</li> </ul>"},{"location":"platform/concept/#specialized-hardware","title":"Specialized Hardware","text":"<ul> <li>In some cases, high-performance architectures may use specialized hardware, such as Graphics Processing Units (GPUs) or Field-Programmable Gate Arrays (FPGAs), to accelerate specific types of computations.</li> </ul>"},{"location":"platform/concept/#optimized-network-architecture","title":"Optimized Network Architecture","text":"<ul> <li>Efficient communication between nodes is critical for high performance. Optimized network architectures, low-latency interconnects, and high-bandwidth connections contribute to overall system efficiency.</li> </ul>"},{"location":"platform/concept/#monitoring-and-performance-tuning","title":"Monitoring and Performance Tuning","text":"<ul> <li>Continuous monitoring and performance tuning are essential to identify and address bottlenecks, optimize resource utilization, and ensure that the system is operating at peak efficiency.</li> </ul>"},{"location":"platform/concept/#asynchronous-and-event-driven-design","title":"Asynchronous and Event-Driven Design","text":"<ul> <li>Asynchronous and event-driven architectures can improve system responsiveness by allowing components to operate independently and respond to events as they occur.</li> </ul> <p>High-performance architectures are tailored to the specific requirements of the applications they support. They often involve a combination of hardware and software optimizations to achieve the desired level of performance for a given workload. It's important to note that designing and maintaining high-performance architectures can be complex and may involve trade-offs between factors such as cost, complexity, and ease of maintenance.</p>"},{"location":"platform/concept/#cap-theorem","title":"CAP theorem","text":"<p>CAP theorem, also known as Brewer's theorem, is a concept in distributed systems that addresses the trade-offs among three fundamental aspects: Consistency, Availability, and Partition Tolerance. It was introduced by computer scientist Eric Brewer in 2000. The CAP theorem suggests that in a distributed system, it is impossible to simultaneously achieve all three of these guarantees. A system can provide at most two out of the three.</p> <p>Here are the key components of the CAP theorem:</p>"},{"location":"platform/concept/#consistency-c","title":"Consistency (C)","text":"<ul> <li>Definition: Every read receives the most recent write or an error. In other words, all nodes in the system see the same data at the same time.</li> <li>Implication: Ensuring consistency means that any read operation on the system will reflect the most recent write, even in the presence of concurrent operations.</li> </ul>"},{"location":"platform/concept/#availability-a","title":"Availability (A)","text":"<ul> <li>Definition: Every request for a read or write operation receives a response without the guarantee that it contains the most recent version of the data.</li> <li>Implication: An available system can provide a response to read or write requests even if it may not reflect the most recent update. The system is operational and accessible.</li> </ul>"},{"location":"platform/concept/#partition-tolerance-p","title":"Partition Tolerance (P)","text":"<ul> <li>Definition: The system continues to operate even when network partitions occur, meaning that communication between nodes is lost or delayed.</li> <li>Implication: In a partition-tolerant system, the network can be unreliable or experience failures, and the system can still function.</li> </ul> <p>According to the CAP theorem, a distributed system can prioritize at most two of these three guarantees, and the choice depends on the system's requirements and the nature of the application. Here are three possible scenarios:</p> <ul> <li>CA (Consistency and Availability): In scenarios where network partitions are rare and can be quickly resolved, a system may prioritize consistency and availability. This is common in traditional relational databases where consistency is crucial.</li> <li>CP (Consistency and Partition Tolerance): In scenarios where the network is unreliable, and partitions are frequent, a system may prioritize consistency and partition tolerance. This is common in systems that require strong consistency, such as many distributed databases.</li> <li>AP (Availability and Partition Tolerance): In scenarios where network partitions are common, and the system needs to remain operational, a system may prioritize availability and partition tolerance. This is common in systems where high availability and fault tolerance are critical, even if it means sacrificing strong consistency.</li> </ul> <p> </p> Source: Wikipedia - CAP Theorem <p>It's important to note that the CAP theorem provides a theoretical framework for understanding trade-offs in distributed systems but does not prescribe specific solutions. Different systems may make different choices based on their specific requirements and use cases. Additionally, advancements in distributed systems research have led to the exploration of systems that aim to provide a balance between the three aspects, challenging the strict interpretation of the CAP theorem in some cases.</p>"},{"location":"platform/concept/#scalability_1","title":"Scalability","text":"<p>Scalability in the context of computer systems refers to the ability of a system to handle an increasing amount of work, or its potential to be enlarged to accommodate that growth. There are several types of scalability that are often discussed in the field of computing:</p>"},{"location":"platform/concept/#vertical-scalability-scale-up","title":"Vertical Scalability (Scale-Up)","text":"Definition Vertical scalability involves adding more resources to a single node or machine in order to increase its capacity. Example Upgrading the CPU, adding more RAM, or increasing storage on a server. Pros Cons Simplicity in implementation. There's a limit to how much a single machine can be scaled vertically. it can be cost-effective for certain applications. It may also lead to downtime during upgrades."},{"location":"platform/concept/#horizontal-scalability-scale-out","title":"Horizontal Scalability (Scale-Out)","text":"Definition Horizontal scalability involves adding more nodes or machines to a system, distributing the load across multiple machines. Example Adding more servers to a web application to handle increased traffic. Pros Cons Highly scalable, as resources can be easily added by adding more machines. Requires a distributed architecture. Can provide better fault tolerance. Some applications may not be easily parallelized."},{"location":"platform/concept/#load-balancing_1","title":"Load Balancing","text":"Definition Load balancing involves distributing incoming network traffic or workload across multiple servers or resources to optimize resource utilization, maximize throughput, minimize response time, and avoid overloading any single resource. Example A load balancer distributing incoming web requests across multiple web servers. Pros Cons Improves overall system performance, ensures high availability, and can help with fault tolerance. Requires additional infrastructure, and the load balancer itself can become a potential bottleneck."},{"location":"platform/concept/#elastic-scalability","title":"Elastic Scalability","text":"Definition Elastic scalability involves dynamically adjusting resources based on demand. Resources are automatically added or removed as needed. Example Cloud computing platforms that can automatically scale the number of virtual machines based on traffic. Pros Cons Efficient resource utilization, cost-effective as resources are only used when needed. Requires sophisticated monitoring and management systems."},{"location":"platform/concept/#database-scalability","title":"Database Scalability","text":"Definition Database scalability refers to the ability of a database to handle an increasing amount of data and transactions. Vertical Database Scalability: Adding more resources to a single database server (e.g., increasing CPU, RAM). Horizontal Database Scalability: Distributing the database across multiple servers (e.g., sharding or partitioning). Pros Cons Can improve performance and handle increased data loads. Complex to implement, and horizontal scalability may require changes to the database schema."},{"location":"platform/concept/#caching","title":"Caching","text":"Definition Caching involves storing frequently accessed data in a cache to reduce the need to fetch the same data from the original source repeatedly. Example Caching frequently used database queries or the results of computationally expensive operations. Pros Cons Improves response time, reduces load on backend systems. May lead to stale data if not managed properly. <p>Each type of scalability has its own strengths and weaknesses, and the choice of scalability approach depends on the specific requirements and constraints of the system or application being developed. Often, a combination of these scalability types is employed to achieve optimal performance and resource utilization.</p>"},{"location":"platform/concept/#design-patterns","title":"Design Patterns","text":"<p>A design pattern in software development is a general, reusable solution to a common problem that occurs in a particular context within a software design. It's a template or a best practice that addresses a specific design or programming problem. Design patterns aren't complete solutions by themselves; rather, they provide a blueprint for solving certain types of problems.</p> <p>The concept of design patterns was popularized by the book \"Design Patterns: Elements of Reusable Object-Oriented Software,\" written by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, often referred to as the \"Gang of Four\" (GoF)<sup>1</sup>. The book categorizes design patterns into three main types:</p> <ul> <li>Creational Patterns: These patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. Examples include the Singleton pattern, Factory Method pattern, and Abstract Factory pattern.</li> <li>Structural Patterns: These patterns focus on the composition of classes or objects. They help in creating a structure of classes and objects, making it easier to form larger structures. Examples include the Adapter pattern, Decorator pattern, and Composite pattern.</li> <li>Behavioral Patterns: Behavioral patterns are concerned with the interaction and responsibility of objects. They define communication patterns between objects and the responsibility of one object in a given situation. Examples include Observer pattern, Strategy pattern, and Command pattern.</li> </ul> <p>Design patterns provide several benefits in software development:</p> <ul> <li>Reusability: Design patterns promote reusability of solutions to common problems. Once a design pattern is established, it can be applied to similar problems in different parts of the system.</li> <li>Scalability: Using design patterns can enhance the scalability of a system by providing proven solutions that can be applied as the system grows.</li> <li>Maintainability: Patterns make code more maintainable by providing a clear and organized structure. Developers familiar with design patterns can understand the overall architecture more easily.</li> <li>Common Vocabulary: Design patterns establish a common vocabulary for developers. When a developer mentions a particular pattern, others who are familiar with it can quickly understand the solution being implemented.</li> </ul> <p>While design patterns are valuable tools, it's essential to use them judiciously. Not every problem requires a design pattern, and using patterns unnecessarily can lead to overly complex and difficult-to-maintain code. It's important to understand the problem at hand and choose the appropriate design pattern when it genuinely adds value to the solution.</p> <ol> <li> <p>GAMMA, E.; HELM, R.; JOHNSON, R., VLISSIDES, J., Design Patterns: Elements of Reusable Object-Oriented Software, 1\u00aa ed., Addison-Wesley Professional, 1994.\u00a0\u21a9</p> </li> <li> <p>Wikipedia - CAP Theorem \u21a9</p> </li> <li> <p>Gof \u21a9</p> </li> </ol>"},{"location":"platform/config/","title":"Config","text":""},{"location":"platform/config/#spring-cloud-config","title":"Spring Cloud Config","text":"<p>Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system. With the Config Server, you have a central place to manage external properties for applications across all environments.</p> <p>Key components of Spring Cloud Config include:</p> <ul> <li> <p>Config Server: A standalone server that provides a REST API for providing configuration properties to clients. The server is embeddable in a Spring Boot application, by using the <code>@EnableConfigServer</code> annotation. The properties can be stored in various types of repositories (Git, SVN, filesystem, etc.).</p> </li> <li> <p>Config Client: A library for Spring Boot applications. It fetches the configuration properties from the Config Server and bootstrap them into the application's context. It's included in the classpath by adding the <code>spring-cloud-starter-config</code> dependency.</p> </li> <li> <p>Refresh Scope: Spring Cloud Config includes a <code>RefreshScope</code> capability which allows properties to be reloaded without restarting the application. You can expose a <code>/refresh</code> endpoint in your application that, when invoked, will cause the application to re-fetch properties from the Config Server.</p> </li> </ul> <p>Spring Cloud Config Server</p>"},{"location":"platform/discovery/","title":"Discovery","text":"<p>Spring Cloud Discovery is a module in the Spring Cloud framework that provides a way for services to discover and communicate with each other in a distributed system. It helps manage the dynamic nature of microservices by allowing them to register themselves and discover other services without hardcoding their locations.</p> <p>In a distributed system, services often need to communicate with each other to fulfill their functionalities. However, the locations of these services may change frequently due to scaling, failures, or deployments. Spring Cloud Discovery solves this problem by providing a service registry where services can register themselves and provide information about their location, such as IP address and port.</p> <p>The service registry acts as a central database of all the services in the system. When a service needs to communicate with another service, it can query the service registry to obtain the necessary information. This allows services to be decoupled from each other and eliminates the need for hardcoding service locations in the code.</p> <p>Spring Cloud Discovery supports multiple service registry implementations, such as Netflix Eureka, Consul, and ZooKeeper. These implementations provide additional features like service health checks, load balancing, and failover.</p> <p>To use Spring Cloud Discovery, you need to include the necessary dependencies in your project and configure the service registry implementation you want to use. Then, you can annotate your services with @EnableDiscoveryClient to enable service registration and discovery. Spring Cloud Discovery will automatically register your services with the service registry and provide a client library to query the registry for service information.</p> <p>Here's an example of how you can use Spring Cloud Discovery with Netflix Eureka:</p> <pre><code>@SpringBootApplication\n@EnableDiscoveryClient\npublic class MyServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyServiceApplication.class, args);\n    }\n}\n</code></pre> <p>In this example, the @EnableDiscoveryClient annotation enables service registration and discovery using the configured service registry. When the application starts, it will register itself with the service registry and be discoverable by other services.</p> <p>Overall, Spring Cloud Discovery simplifies the process of service discovery and communication in a distributed system, making it easier to build and maintain microservices architectures.</p>"},{"location":"platform/gateway/","title":"Gateway","text":""},{"location":"platform/gateway/#concepts","title":"Concepts","text":"<p>The Gateway design pattern is a structural design pattern that provides a centralized entry point for handling requests from external systems. It acts as a mediator between the client and the server, allowing the client to make requests to multiple services through a single interface.</p> <p>In the context of software development, a gateway acts as an intermediary between the client and the backend services. It abstracts away the complexity of interacting with multiple services by providing a unified API for the client to communicate with.</p> <p>The main benefits of using the Gateway design pattern include:</p> <ul> <li> <p>Simplified client code: The client only needs to interact with the gateway, which handles the routing and communication with the appropriate backend services. This reduces the complexity and coupling in the client code.</p> </li> <li> <p>Centralized cross-cutting concerns: The gateway can handle common concerns such as authentication, authorization, rate limiting, caching, and logging in a centralized manner. This eliminates the need to implement these features in each individual service.</p> </li> <li> <p>Scalability and flexibility: The gateway can distribute requests to multiple instances of backend services, allowing for horizontal scaling. It also provides the flexibility to add or remove backend services without affecting the client code.</p> </li> <li> <p>Protocol translation: The gateway can handle protocol translation, allowing clients to use different protocols (e.g., HTTP, WebSocket) while the backend services can use a different protocol.</p> </li> <li> <p>Service aggregation: The gateway can aggregate data from multiple backend services and provide a unified response to the client. This reduces the number of requests made by the client and improves performance.</p> </li> </ul> <p>To implement the Gateway design pattern, various technologies and frameworks can be used, such as Spring Cloud Gateway, Netflix Zuul, or NGINX. These tools provide features like routing, load balancing, and request filtering, making it easier to build a robust and scalable gateway.</p> <p>In summary, the Gateway design pattern provides a centralized entry point for handling requests from clients and abstracts away the complexity of interacting with multiple backend services. It simplifies client code, centralizes cross-cutting concerns, and provides scalability and flexibility in a distributed system architecture.</p>"},{"location":"platform/gateway/#spring-cloud-gateway","title":"Spring Cloud Gateway","text":"<p>https://spring.io/projects/spring-cloud-gateway/</p>"},{"location":"platform/load-balancing/","title":"Load Balancing","text":""},{"location":"platform/load-balancing/#spring-cloud-loadbalancer","title":"Spring Cloud LoadBalancer","text":"<p>Spring Cloud LoadBalancer is a generic abstraction over load balancing algorithms that you can use with service discovery clients like Eureka, Consul, and Zookeeper. It provides a round-robin load balancing implementation by default, but you can also implement your own custom load balancing algorithms.</p> <p>Key components of Spring Cloud LoadBalancer include:</p> <ul> <li> <p>Dependency: To use Spring Cloud LoadBalancer, you need to include the <code>spring-cloud-starter-loadbalancer</code> dependency in your project.</p> </li> <li> <p>Configuration: By default, Spring Cloud LoadBalancer uses a simple round-robin strategy for load balancing. If you want to customize this, you can create a bean of type <code>ServiceInstanceListSupplier</code> that returns a custom list of instances for load balancing.</p> </li> <li> <p>Usage: You can use the <code>@LoadBalanced</code> annotation on a <code>RestTemplate</code> or <code>WebClient.Builder</code> bean to integrate it with Spring Cloud LoadBalancer. When you make a request through this client, it will automatically be load balanced.</p> </li> </ul>"},{"location":"platform/logging/","title":"Logging","text":""},{"location":"platform/microservices/","title":"Microservices","text":""},{"location":"platform/microservices/#microservices-concepts","title":"Microservices Concepts","text":"<p>Microservices, also known as the microservices architecture, is an architectural style that structures an application as a collection of small autonomous services, modeled around a business domain.</p> <p>Key concepts of microservices include:</p> <ul> <li>Single Responsibility: Each microservice should have a single responsibility and should implement a single business capability.</li> <li>Independence: Microservices should be able to run and evolve independently of each other. They should be independently deployable and scalable.</li> <li>Decentralization: Microservices architecture favors decentralized governance. Teams have the freedom to choose the best technology stack that suits their service.</li> <li>Isolation of Failures: If a microservice fails, it should not impact the availability of other services.</li> <li>Data Isolation: Each microservice should have its own database to ensure that the services are loosely coupled and can evolve independently.</li> <li>Communication: Microservices communicate with each other through well-defined APIs and protocols, typically HTTP/REST with JSON or gRPC with Protobuf.</li> <li>Infrastructure Automation: Due to the distributed nature of the microservices architecture, automation of infrastructure is a must. This includes automated provisioning, scaling, and deployment.</li> <li>Observability: With many different services, it's important to have excellent monitoring and logging to detect and diagnose problems.</li> </ul>"},{"location":"platform/microservices/#domain-driven-design","title":"Domain Driven Design","text":"<p>Domain-Driven Design (DDD) is a software development approach that emphasizes collaboration between technical experts and domain experts. The goal is to create software that is a deep reflection of the underlying domain, which is the specific area of business or activity that the software is intended to support.</p> <p>Key concepts of DDD include:</p> <ul> <li>Ubiquitous Language: A common language established between developers and domain experts, used to describe all aspects of the domain.</li> <li>Bounded Context: A boundary within which a particular model is defined and applicable.</li> <li>Entities: Objects that have a distinct identity that persists over time and across different representations.</li> <li>Value Objects: Objects that are defined by their attributes, not their identity.</li> <li>Aggregates: Clusters of entities and value objects that are treated as a single unit.</li> <li>Repositories: They provide a way to obtain references to aggregates.</li> <li>Domain Events: Events that domain experts care about.</li> <li>Services: Operations that don't naturally belong to any entity or value object.</li> </ul> <p>By focusing on the domain and domain logic, DDD provides techniques to develop complex systems targeting real-world scenarios. It helps to reduce the complexity by dividing the system into manageable and interconnected parts.</p> <p> </p> Source: System Design 101 - Microservice Architecture"},{"location":"platform/microservices/#design-a-microservice-platform","title":"Design a Microservice Platform","text":"<pre><code>flowchart LR\n  subgraph Client\n    direction LR\n    Web\n    Mobile\n    Desktop\n  end\n  subgraph Microservices\n    direction LR\n    gateway[\"Gateway\"]\n    subgraph Essentials\n      direction TB\n      discovery[\"Discovery\"]\n      auth[\"Auth\"]\n      config[\"Configuration\"]\n    end\n    subgraph Businesses\n      direction TB\n      ms1[\"Service 1\"]\n      ms2[\"Service 2\"]\n      ms3[\"Service 3\"]\n    end\n  end\n  Client --&gt; lb[\"Load Balance\"] --&gt; gateway --&gt; Businesses\n  gateway --&gt; auth\n  gateway --&gt; discovery\n  click gateway \"../gateway/\" \"Gateway\"\n  click discovery \"../discovery/\" \"Discovery\"\n  click auth \"../auth-service/\" \"Auth\"\n  click config \"../config/\" \"Configuration\"\n  click lb \"../load-balancing/\" \"Load Balance\"</code></pre>"},{"location":"platform/microservices/#containering","title":"Containering:","text":"<p>Many microservices implies in many ports, then a complicated environment to manage</p>"},{"location":"platform/microservices/#gateway","title":"Gateway","text":""},{"location":"platform/microservices/#discovery","title":"Discovery","text":""},{"location":"platform/microservices/#communication","title":"Communication","text":"<ol> <li> <p>XU, A., System Design 101.\u00a0\u21a9</p> </li> <li> <p>Wikipedia - Domain Driven Design \u21a9</p> </li> </ol>"},{"location":"platform/monitoring/","title":"Monitoring","text":""},{"location":"platform/payment/","title":"Payment","text":"<p>FinOps</p>"},{"location":"platform/database/caching/","title":"Caching","text":"<p>Spring Boot Cache</p> <p>https://docs.spring.io/spring-framework/docs/4.1.5.RELEASE/spring-framework-reference/html/cache.html</p> <p>Redis</p> <p>https://medium.com/nstech/programa%C3%A7%C3%A3o-reativa-com-spring-boot-webflux-e-mongodb-chega-de-sofrer-f92fb64517c3</p>"},{"location":"platform/database/caching/#handout-redis","title":"Handout Redis","text":""},{"location":"platform/database/flyway/","title":"Flyway","text":""},{"location":"platform/database/flyway/#flyway","title":"Flyway","text":"<p>Flyway is an open-source database migration tool that strongly favors simplicity and convention over configuration. It is designed to simplify the process of versioning a database, similar to how Git versions source code. </p> <p>With Flyway, you can apply version control to your database which allows you to migrate it to a newer version and also revert changes if needed. Flyway uses SQL scripts or Java-based migrations to evolve your database schema in a way that is controllable and predictable.</p> <p>Key features of Flyway include:</p> <ul> <li>Version control for your database: Allows you to track changes and apply version control to your database, similar to how you would with your source code.</li> <li>Support for SQL and Java-based migrations: You can use SQL for simple changes, and Java for complex migrations.</li> <li>Repeatable migrations: You can use this feature to manage objects in your database that can't be easily handled with versioned migrations, like stored procedures and views.</li> <li>Multiple database support: Flyway supports a wide variety of databases including MySQL, PostgreSQL, SQL Server, and more.</li> </ul> <p>https://www.baeldung.com/liquibase-vs-flyway</p> <ol> <li> <p>https://www.baeldung.com/database-migrations-with-flyway\u00a0\u21a9</p> </li> </ol>"},{"location":"versions/2024.1/","title":"2024.1","text":"<p>Prof. Humberto Sandmann</p> <p>humbertors@insper.edu.br</p>"},{"location":"versions/2024.1/#meetings","title":"Meetings","text":"Evento Dia In\u00edcio T\u00e9rmino Aula Qua. 09h45 11h45 Aula Sex. 07h30 09h30 Atendimento Seg. 12h00 13h30"},{"location":"versions/2024.1/#grades","title":"Grades","text":"Avalia\u00e7\u00e3o Descri\u00e7\u00e3o Nota (%) CP1 Montar um Spring Cloud 7.5 CP2 Jenkins &amp; Bottlenecks 7.5 CP3 K8s 7.5 CP4 Platform as a Product 7.5 Apresenta\u00e7\u00e3o 10.0 Projeto 60.0"},{"location":"versions/2024.1/#planning","title":"Planning","text":"calend\u00e1rioaula-a-aula"},{"location":"versions/2024.1/#repository-template","title":"Repository Template","text":"<p>Cluster</p> Reposit\u00f3rio Comando Docker Compose API <code>docker compose up --build</code> <code>docker compose down</code> <p>Infra</p> Microsservi\u00e7o Implementa\u00e7\u00e3o Gateway Discovery platform.241.store.discovery <p>API</p> Microsservi\u00e7o Descri\u00e7\u00e3o Interface Implementa\u00e7\u00e3o Account platform.241.store.account platform.241.store.account-resource Auth"},{"location":"versions/2024.1/#project","title":"Project","text":"<p>Projetos come\u00e7am. Terminam?</p> <p>Sugest\u00e3o de Roteiros</p> <ol> <li> <p>Organiza\u00e7\u00e3o</p> <p>a. Eleja uma ferramenta para gerenciar a documenta\u00e7\u00e3o da arquitetura</p> </li> <li> <p>Planejar</p> <p>a. Monte um diagrama com os dom\u00ednios e microsservi\u00e7os candidatos de seu sistema;</p> <p>b. Tente levantar quais s\u00e3o os endpoints que o sistema necessita;</p> <pre><code>* Separe os *endpoints* entre *abertos* e *fechados*;\n* Se necess\u00e1rio, projete o microsservi\u00e7o de seguran\u00e7a;\n* Adicione ao seu projeto um fluxo de inform\u00e1\u00e7\u00f5es entre microsservi\u00e7os;\n</code></pre> <p>c. Identifique poss\u00edveis (te\u00f3ricos) bottlenecks em seu sistema;</p> <pre><code>- Se existirem *bottlenecks*, ent\u00e3o, elenque (sem implementar) poss\u00edveis solu\u00e7\u00f5es.\n</code></pre> <p>d. Revise toda a arquitetura montada, reiniciando todo o processo pelo item 1, se necess\u00e1rio.</p> </li> <li> <p>Criar</p> <p>a. Escolha um framework adequado (mandat\u00f3rio Spring Boot Cloud);</p> <p>b. Implemente a API;</p> <p>c. Documente a API (OpenAPI)</p> </li> <li> <p>Testar</p> </li> <li> <p>Empacotar</p> </li> <li> <p>CI/CD</p> </li> <li> <p>Escalando o Sistema</p> <p>a. distribuia</p> <p>b. configure</p> <p>c. monitore</p> </li> <li> <p>Mitigando Bottlenecks</p> <p>a. sobre os bottlenecks identificados, teoricamente ou durante a implementa\u00e7\u00e3o, crie um plano de altera\u00e7\u00e3o na arquitetura de maneira a mitigar tais impactos;</p> <p>b. revise toda a arquitetura em busca de coer\u00eancia.</p> </li> </ol>"}]}